Abbiamo implementato un algoritmo di ordinamento dei campioni tramite una versione parallela di Quicksort. I nostri esperimenti computazionali mostrano che Quicksort parallelo risulta essere piú veloce rispetto all'ordinamento del campione fatto in modo iterativo utilizzando un solo  Processore. Su 32 processori del Power7 la velocità di Quicksort parallela è più di ........
 unità superiori della velocità del Quicksort Iterativo, con tempi di esecuzione più elevati del .........% rispetto all'ordinamento dei campioni. 
L'algoritmo Quicksort parallelo che abbiamo implementato è una semplice estensione Quicksort, dove l'array di input viene suddiviso in parti uguali a tutti i processori, e ogni processore esegue una serie di Round che permettono di ordinare la parte assegnata ad ogni processore. Una volta finito un round, sincronizza la parte dell'array a lui assegnato, inviando una richiesta non bloccante al proprio root che permettera di proseguire al prossimo round. Queste richieste permetteranno la comunicazione dello stato dei processori e dell'aggiornamento del array di partenza, che a causa della assenza della memoria condivisa ogni processore non sa se altri processori lavorano su stesse locazioni di memoria.


L'Algoritmo

Quicksort è un algoritmo di ordinamento sequenziale ampiamente ritenuto essere l'algoritmo di ordinamento sequenziale più veloce per un ampio set di input.
È un algoritmo ricorsivo che usa il metodo "Divide and Conquer" per ordinare tutti i valori. Quicksort standard preleva prima una chiave dall'elenco, il pivot e trova
la sua posizione nell'elenco in cui deve essere posizionata la chiave, nel nostro caso abbiamo implementato la funzione "PivotChoice" che seleziona 3 valori rand presi nel nostro array e calcola la media del massimo e minimo valore scelto. Una volta trovato il Pivot, avremo due possibilità:
-I valori minori al pivot saranno posizionati nella parte "inferiore" dell'array
-I valori maggiori o uguali saranno posizionati nella parte "superiore" dell'array
